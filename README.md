ctrl + shift + t открыть только что закрытую вкладку в браузере
ctrl + z; ctr; + shift + z - туда сюда
ctrl + space - додумывалка

TodoList lesson 1

Создаем компоненту Todolist и выносим в отдельный файл
Для выноса в отдельный файл используем F6

Если мы в jsx разметке указываем в атрибуте текст то достаточно обернуть его в кавычки 
но вообще после знака = нужно ставить {}

Если экспортируем компоненту по дефолту то в импорте можем менять название но тогда и этой компоненте нужно указывать
наименование как в импорте что в целом вводит путаницу так что является бесполезной возможностью

Экспортируем без дефолта

Когда нам нужно затипизировать массив с объектами 
нужно сначала создать типизацию для конкретного объекта в массиве и уже потом указывать это наименовение после

type TaskType = {
    id: number
    title: string
    isDone: boolean
}

type PropsType = {
   tasks : Array<TaskType> or TaskType[]
}

Искать проблему нужно в том числе на одно действие выше от ошибки

Чтобы не ошибиться во время описания объектов можем использовать уже написанную типизацию 
в том числе и из других компонент

Todolist.tsx

export type TaskType = {
    id: number
    title: string
    isDone: boolean
}

App.tsx

let tasks_2: Array<TaskType> = [
    {id: 1, title: 'satisfaction', isDone: true },
    {id: 2, title: 'satisfaction', isDone: true },
    {id: 3, title: 'satisfaction', isDone: false },
]

TodoList Lesson 2

Данные помещены в App компонент и эти данные передаем в Todolist компонент
Данные в App потому что мы не собираемся рисовать 2 компоненты
В Todolist данные мы будем хранить в UI в компоненте App потому что у React 
есть механизмы хранения и управления данными, но в реальной жизни этот локальный стейт
managment используется для локальных не больших заданий

Для большого управления state используется redux
Пока данные хранятся в виде переменных в App компоненте и мы эти данные прокидываем
в разные Todolist, мы не храним эти данные в Todolist потому что его мы отрисовываем несколько раз
а App один раз а значит Todolist при каждой отрисовке они должен быть разным поэтому так

Теперь если мы добавим 4 объект в массив объектов tasks то увидим что 4 объект не отобразился
id должен быть уникальным (уникальный идентификатор объекта)

Наша разметка зависит от данных которые мы в эту разметку помещаем мы как программисты
думаем как нам правильно составлять данные и как их потом менять а разметка автоматически сама подстроится

Мы добавили 4 элемент а разметка сама не подстроилась
этого не произошло потому что компонент TodoList не правильно структурирован
не правильно построен

Основная ошибка в том что мы явно обращаемся к элементам в массиве по индексу
мы как-будто знаем что у нас должно быть строго 3 таски 
Поэтому 4 таска и не отрисовывается потому что ее просто нет
Поэтому если мы удалим в таскс 2 3 объект приложение будет просто показывать белый экран

Если мы обратимся по индексу массива а в массиве ничего не будет нам вернется undefined

Поэтому код нашей компоненты - не гибкий он не заточен под любое количество тасок
которое может прийти а может и не прийтий

Поэтому мы должны использовать здесь метод массива map
массив это объект
в Todolist в ul Ставим {обозначаем что мы сейчас будем работать с js}
массив находится в props
props.tasks это какой-то массив тасок который приходит в нашу компоненту

Todolist может отрисовываться много раз и tasks могут быть разными и они находятся
в props
props это объект который приходит в нашу компоненту чтобы наша компонента на основе этих данных
могла отрисовать какую-то другую разметку например заголовок props.title 
или например список тасок
поэтому мы должны пробежаться по каждому элементу по каждому объекту в массиве
и делаем это с помощью функции map

{
    props.tasks.map
}

в отличие от forEach map после каждой итерации возвращает на основе старого объекта - новый объект
в новом массиве, нам нужно чтобы он вернул на основе этого объекта - элемент списка - li

1 в map передаю стрелочную функцию

{
    props.tasks.map(  () => {} )
}

Единственным параметром который передается в map является callback функция
с помощью map callback функция вызывается для каждого элемента в tasksData_1_2
этот параметр можно назвать как угодно но лучше чтобы он был в контексте программы

<ul>
    {
        props.tasksDataApp.map((tasksDataAppItem) => {
            return (
                <li><input type="checkbox" defaultChecked={props.tasksDataApp[0].isDone}/> <span>{props.tasksDataApp[0].title}</span></li>
            )
        })
    }

то есть map возьмет на основе всех объектов tasks создаст столько же li сколько в tasks находится объектов
но чтобы значения в этой li согласовывались с данными из объектов tasks мы должны считывать эти значения уже не по индексу
а прямо из параметра callback функции tasksDataAppItem поэтому в li будут следующие изменения

<ul>
    {
        props.tasksDataApp.map((tasksDataAppItem) => {
            return (
                <li><input type="checkbox" defaultChecked={tasksDataAppItem.isDone}/> <span>{tasksDataAppItem.title}</span></li>
            )
        })
    }
</ul>

И теперь независимо от того сколько объектов мы добавим в массив tasks у нас соответствующее количество
отрисуется и соотв если я укажу в tasksData 2 что у меня 2 объекта то и отрисуется 2 объекта

Рефакторинг так как ничего кроме return функция в map не делает то мы можем сократить запись

Map - метод массива который на основе каждого объекта в массиве создает какой-то другой элемент
на выходе мы получаем массив с этими новыми элементами

То есть теперь мы просто меняя данные можем автоматически менять разметку

То есть теперь если мы научимся как-то менять эти данные программным способом, при кликах
по кнопкам и т.д. то у нас будет автоматически происходить перерисовка
и первое что мы научимся делать - удалять таски

Добавляем кнопки справа от span в li

<button>x</button>

Учимся реагировать на события, когда по какому-либо элементу по кнопке например мы кликаем
этот элемент генерирует событие клик, но так как никто это собтие не слушает не мониторит
то ничего и не происходит поэтому создаем такого слушателя и добавим тегу button 
атрибут onClick
Далее так указываем функцию callback 
Когда произойдет клик функция callback как раз сообщит об этом событии внешнему миру
через функцию которую нужно будет вызвать которую вызовет кнопка когда с ней произойдет событие

И мы отдаем кнопке стрелочную функцию 

<button onClick={() => {}}>x</button>
 
Добавим окошко которое будет вылетать по клику с надписью click

 <ul>
    {
        props.tasksDataApp.map((tasksDataAppItem) =>
            <li>
                <input type="checkbox" defaultChecked={tasksDataAppItem.isDone}/>
                <span>{tasksDataAppItem.title}</span>
                <button className={'deleteButton'} onClick={() => {alert('click')}}>x</button>
            </li>
        )
    }
</ul>

и теперь после нажатия на любую кнопку x будет выводиться окно с надписью click

так как на другие кнопки мы не вешали события onClick то ничего после нажатия по ним не происходит

Функция кнопки x - удалять из отображения браузера конкретную таску, а чтобы реакту было понятно
какую именно таску нужно удалять мы должны каким-то образом идентифицировать конкретный элемент который 
должен быть удален после нажатия на кнопку

Эта идентификация объектов с которыми нужно что-то сделать происходит по id

То есть нам нужно знать id объекта когда мы хотим его например удалить
Вместо click выведем id объекта
мы находимся внутри стрелочной функции которую мы передали в метод map 
map вызывает эту стрелочную функцию для каждой таски в этом массиве поочереди
и при каждом вызове эта таска попадает в параметр tasksDataAppItem
для которой мы рисуем конкретную li для которой рисуем конкретную кнопку
для которой хотим показать алерт то есть мы к конкретной таске можем достучаться через

tasksDataAppItem

и я могу к этому tasksDataAppItem обратиться как к объекту со свойствами каждой таски
например к свойству id

<button onClick={() => { alert(tasksDataAppItem.id) }}>x</button>

то есть при клике на конкретную кнопку теперь у меня будет отображаться id той таски рядом
с которой я кликнул кнопку то есть мы получили ту самую связь

то есть при клике на кнопку которая лежит в li которая отрисовалась для конкретной tasksDataAppItem
мы повесили конкретную функцию обработчик onClick={() => { alert(tasksDataAppItem.id) }
на клик конкретной кнопки конкретной li и эта конкретная функция покажет в alert id той таски 
рядом с которой я кликнул кнопку

Для упрощения пока удалим 1 Todolist

Наша задача удалить таску удалить ее мы можем только из данных в компоненте Todolist мы ее удалить не можем
массив с тасками находится в App компоненте

То есть данные хранятся в App мы эти данные просто как пропсы прокидываем в Todolist и 
Todolist их просто рисует но мы знаем что если мы данные будем менять

то есть мы при нажатии на какие-либо кнопки всегда думаем как нам поменять данные а уже потом
на основе этих данных произойдет перерисвока

То есть мы должны таким образом писать код для компоненты чтобы потом если вдруг данные меняются
автоматически происходила перерисовка 
Мы подготовили компоненту теперь нужно научиться менять данные

Данные могут менять только функции которые лежат там же где и данные 
Но функцию чтобы она поменяла данные нужно запустить App сама не может запустить такую функцию
потому что она не знает когда но Todolist знает когда нужно запустить эту функцию удаления

Потому что кнопки удаления лежат в Todolist и фактически когда мы кликаем по Tosolist нужно запустить
эту функцию которая лежит в App
Когда у нас данные лежали в App мы передали их в Todolist через props и функция у нас лежит там вверху
и мы ее передадим в Todolist так же через props то есть функция является в js объектом значит ее можно брать
и передавать (передать callback когда сам владелец функции ее не вызывает) App ее не вызывает
а передает куда-то внутрь мы так уже делали с функцией alert('click')

То есть мы ее сами не вызываем мы ее передаем кнопке
<button onClick={() => { alert(tasksDataAppItem.id) }}>x</button>
И говорим кнопка когда по тебе кликнут (onclick) вызови нашу функцию callback

В какой-то степени сама компонента является функцией callback потому что мы ее не вызываем 
мы не видим кода где у нас конкретно пишется Todolist(); - то есть вызов функции Todolist
Мы даем инструкцию react в виде jsx разметки и потом эту функцию вызывает React 

Есть еще одна функция callback это map мы в map в качестве параметра тоже передаем стрелочную функцию
которая принимает таску и возвращает li мы эту функцию не вызываем мы ее отдаем map то есть другой функции
и эта функция map запускает для каждой таски функцию callback

Под задачу удалить таску из массива напишем функцию удаления таски из массива в App

function removeTask() {

}

Но мы не можем удалить таску не зная какую именно таску удалить
то есть нам как функции удаления нужны входные данные

Функция removeTask лежит там же где и массив с объектам
Удалять объекты из массива будем по id и тут же будет необходимо определить тип под id: number

function removeTask(id: number) {

}

Теперь нам нужно взять этот массив тасок и его изменить, оставив все таски кроме одной
той которую мы удалили для этого используем метод массива filter

map на основе старого массива создает новый массив изменяя каким-либо образом все элементы массива

а filter так же пробегает по всем объектам и пропускает в результирующий массив только те объекты
которые удовлетворяют условию то есть только те таски для которых функция callback переданная в filter
вернёт true 
То есть в новом массиве после filter будут только те таски после прохождения по фильтру которых
filter вернет true

Если написать 

function removeTask(id: number) {
    let filteredTasksData = tasksData.filter(() => {return true})
    console.log(filteredTasksData)
}

то filter вернет те же самые объекты но в новом массиве
Для того чтобы это проверить вызовем эту функцию после клика по кнопке
кнопка находится в Todolist а функция находится в App
значит функцию нужно передать в Todolist через props

<Todolist
    title={'push me'}
    tasksDataApp={tasksData}
    removeTask={removeTask}
/>

в типизации мы укажем 

type TodolistType = {
    title: string
    tasksDataApp: Array<TaskDataType>
    removeTask: Function
}

и теперь мы можем вместо alert вызвать функцию которая у нас находится в props 

То есть мы можем написать вместо alert props.removeTask.id таким образом передать в функцию id той кнопки
на которую мы нажали для удаления таски

<button onClick={() => { alert(tasksDataAppItem.id) }}>x</button>            Было
<button onClick={() => { props.removeTask(tasksDataAppItem.id) }}>x</button> Стало

Итого кнопку нажали в Todolist а функция работает из App компоненты
то есть вызов функции removeTask() произошел в Todolist не смотря на то что сама функция находится в App

Теперь мы должны настроить правильную фильтрацию

То есть мы должны пропустить только те таски у которых id не равна той id которую надо удалить
(на х рядом с которой мы нажали)

как и с map каждая таска приходит с параметром callback функции назовем его 

removeTaskItem

Далее в filter пишем условие по которому нам фильтр будет фильтровать проходящие через него
объекты массива и после каждого выдавать соотв true либо false

То есть мы говорим если task.id (таска по которой пробегается фильтр) если ее id не равен
id которая пришла в функцию после клика по кнопке в Todolist то мы тогд возвращаем true
и таску отображаем
а если id таски фильтра равна id таски с кнопки х todolista то возвращаем false и таску не отображаем

function removeTask(id: number) {
    let filteredTasksData = tasksData.filter((filteredTask) => {
    if (filteredTask.id !== id) return true
    else return false
    })
}

То есть мы выше сравниваем id кнопки по которой мы нажали с id таски из данных, и если они совпадают
не показываем эту таску с помощью того что фильтр возращает новый массив уже без нее
т.о. мы меняем данные

Если мы нажмем на x с id 3 то для таски с id 3 filter вернет false значит эта таска не попадет в 
результирующий массив 

if (1 !== 3) true - отобрази
if (2 !== 3) true - отобрази
if (3 !== 3) false - не отображай
if (4 !== 3) true - отобрази

Соответственно в результирующем массиве у нас будут таски с id 1 2 4 а 3 - нет

_________________________Рефакторим filter 

так как булевое выражение итак нам возращает true либо false
то
мы можем упростить наш код

function removeTask(id: number) {
    let filteredTasksData = tasksData.filter((filteredTask) => {
    return filteredTask.id !== id
}
filteredTask.id !== id превращается либо в true либо в false
а filter добавит в новый массив только там где true
поэтому id присовпадении не попадут в результирующий массив

Если наша стрелочная функция не делает ничего кроме return то мы можем удалить {} и return

итого

function removeTask(id: number) {
    let filteredTasksData = tasksData.filter(filteredTask => filteredTask.id !== id)
}

Фильтр пропусти те таски id которых не равна id которую надо удалить

Но это все будет отображать уже в другом массиве, старый массив мы не меняли
фильтрация не меняет старый массив она пробегается по старому массиву и создает новый массив
с отфильтрованными тасками поэтому этот массив не изменился поэтому на данном этапе перерисовки 
после нажатия на х - нет

Но мы можем не создавать новую переменную filteredTasksData а так как у нас массив данных объявлен с помощью
let то мы можем просто переприсвоить тому же самому массиву данных tasksData новое значение
поэтому

из 

function removeTask(id: number) {
    let filteredTasksData = tasksData.filter(filteredTask => filteredTask.id !== id)
}

мы делаем 

function removeTask(id: number) {
    let tasksData = tasksData.filter(filteredTask => filteredTask.id !== id)
}

Если функция видит внутри себя наименование переменной которой нет внутри этой функции
то она ее берет из замыкания снаружи, за пределами литерала {} функции 
Это называется замыкание

Итак на данный момент после нажатия x через debugger видим как такси удаляются 
а в браузере перерисовка не происходит

Потому что реакт отрисовывает App Todolist и так далее по цепочке, останавливается, и только потом
мы нажимаем кнопку, данные изменяются но React заново не отрисовывает страницу поэтому на странице 
ничего не меняется

Потому что данные нам нужно хранить определенным специальным образом чтобы эта перерисовка происходила
автоматически

в пути самурая rerenderentiretree мы насильно извне перерисовываем компоненту 

Здесь мы будем использовать локальный стейт компонента

Раньше существовало два типа компонент функциональные и классовые

классовый компонент то что уходит в прошлое но раньше они широко использовались
потому что классовые компоненты имеют локальный стейт
Локальный стейт, это такой стейт, который если меняется реакт компоненту перерисовывает

в функциональных компонентах такого не было, но в функциональных компонентах
научились использовать локальный стейт с помощью хука useState

useState

Скажем что мы будем хранить таски по другому не в переменной tasks а в useState

useState() это специальная функция-хук которая находится в реакте при использовании
он импортируется из реакт

мы говорим useState - сохрани данные в стейт который будет отслеживаться реактом и если данные изменятся
то реакт автоматически перерисует компоненту в который мы написали useState

useState - хранилище он конкретно прописан в App значит у App появляется свое хранилище
за которым React наблюдает и мы в этот useState помещаем нам массив tasks

useState(tasks)

Нам этим массивом нужно как-то пользоваться
То что мы помещаем tasks в useState это первоначальное состояние, initial state - которому со старта будет 
равняться наш стейт при первом его написании.

Но он со временем может поменяться, и нам нужно к измененному таскс обращаться а
к измененному таск мы не можем обращаться

Поэтому useState наружу отдает массив в котором находится два элемента

let array = [data, () => {}] 1 элемент это данные, а второй - функция которая эти данные меняет

в нашем случае вместо data данных выступает массив объектов [{},{},{}] и функция которая может этот массив поменять
() => {}

и вот useHook нам возвращает такой массив let array = [ [{},{},{}], () => {}] 

то есть мы вызываем функцию

useState()

которая принимает данные

useState(data) 

и которая возвращает массив

useState2(data) {
    return [ [{},{},{}], () => {}];
}

то есть мы вызываем useState2() и говорим вот тебе массив tasks

useState([{},{},{}])

useState берет массив тасок и возвращает обратно

useState2(data) {
    return [ data, () => {}];
}

только упаковывает data которые пришли в useState2(data: any) в массив
а рядом с этим первым элементом делает данные которые мы ей и передали массив тасок
то есть в useState2(data: any) массив тасок а вторым парамтером функцию которая этот массив тасок 
умеет менять

и нам этот массив возвращается обратно

let array = useState2({},{},{})

и мы можем обратиться к array[0] и это будет массив тасок который мы и передали
и можем обратиться к array[1] чтобы получить функцию которая меняет данные
и обычно эти два значения присваются и говорят 

let tasks = array[0]

а функция которая сидит вторым элементом в этом массиве называется 

setTasks = array[1] установить таски

То есть useState нам возвращает массив

let array = useState(tasksData)

и в этом array сидит 2 элемента

под первым элементом сидят таски
под вторым элементом сидит функция которую мы можем вызвать чтобы установить новые таски

let tasksDataUseState = array[0]
let setTasks = array[1]

то есть когда мы изменим массив tasksData мы можем этот массив отправить в 
функцию setTasks и таски изменятся там в стейте который контролируется реактом
и реакт автоматически запустит перерисовку

фильтр фильтрует по тасксдата мы получили фильтрованные таски
и теперь если мы эти отфильтрованные таски отправим в функцию setTasks
тем самым мы скажем что измени в стейте таски которые там были 
setTasks(filteredTasks)

function removeTask(id: number) {
    let filteredTasks = useStateTasksData.filter(filteredTask => filteredTask.id !== id)
    setTasks(filteredTasks)
}

А раз таски изменились с помощью setTasks реакт запустит перерисовку
точнее чтобы перерисовку вообще получить реакту нужно запустить заново функцию в которой 
этот стейт изменился

Реакт заново перезапускает функцию App он видит что мы используем функцию 

let arrayUseState = useState(tasksData)

и в этот useState засовываем опять 4 таски из tasksData

То есть у нас 4 таски из tasksData поместились в стейт

let arrayUseState = useState(tasksData)

таска потом удаляется и мы в стейте оставляем только три таски

setTasks(filteredTasks)

И реакт зная что стейт изменился перезапускает функцию App
и он видит опять что мы помещаем 4 таски в useState но useState больше их в себя не помещает
потому что это уже было то есть инициализационного начального значения массива tasksData 
как-будто уже и не происходит

let tasksData = ;

let arrayUseState = useState()

эта часть кода пропускается далее видит useState из useState достаю массив

let arrayUseState = useState()

let useStateTasksData = arrayUseState[0] в этом массиве беру первый элемент
там уже после удаления осталось три таски 

по прежнему получаю функцию которую опять можно вызывать чтобы опять изменять таски

let setTasks = arrayUseState[1]

и иду вниз и отрисовываю опять Todolist и передаю уже три таски туда внутрь

tasksDataApp={useStateTasksData}

<Todolist
    title={'push me'}
    tasksDataApp={useStateTasksData}
    removeTask={removeTask}
/>








































