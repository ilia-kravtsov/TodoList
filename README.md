ctrl + shift + t открыть только что закрытую вкладку в браузере
ctrl + z; ctr; + shift + z - туда сюда
ctrl + space - додумывалка

TodoList lesson 1

Создаем компоненту Todolist и выносим в отдельный файл
Для выноса в отдельный файл используем F6

Если мы в jsx разметке указываем в атрибуте текст то достаточно обернуть его в кавычки 
но вообще после знака = нужно ставить {}

Если экспортируем компоненту по дефолту то в импорте можем менять название но тогда и этой компоненте нужно указывать
наименование как в импорте что в целом вводит путаницу так что является бесполезной возможностью

Экспортируем без дефолта

Когда нам нужно затипизировать массив с объектами 
нужно сначала создать типизацию для конкретного объекта в массиве и уже потом указывать это наименовение после

type TasksDataType = {
    id: number
    title: string
    isDone: boolean
}

type PropsType = {
    tasksData : Array<TasksDataType> or TasksDataType[]
}

Искать проблему нужно в том числе на одно действие выше от ошибки

Чтобы не ошибиться во время описания объектов можем использовать уже написанную типизацию 
в том числе и из других компонент

Todolist.tsx

export type TasksDataType = {
    id: number
    title: string
    isDone: boolean
}

App.tsx

let tasks_2: Array<TasksDataType> = [
    {id: 1, title: 'satisfaction', isDone: true },
    {id: 2, title: 'satisfaction', isDone: true },
    {id: 3, title: 'satisfaction', isDone: false },
]

TodoList Lesson 2

Данные помещены в App компонент и эти данные передаем в Todolist компонент
Данные в App потому что мы не собираемся рисовать 2 компоненты
В Todolist данные мы будем хранить в UI в компоненте App потому что у React 
есть механизмы хранения и управления данными, но в реальной жизни этот локальный стейт
managment используется для локальных не больших заданий

Для большого управления state используется redux
Пока данные хранятся в виде переменных в App компоненте и мы эти данные прокидываем
в разные Todolist, мы не храним эти данные в Todolist потому что его мы отрисовываем несколько раз
а App один раз а значит Todolist при каждой отрисовке они должен быть разным поэтому так

Теперь если мы добавим 4 объект в массив объектов tasks то увидим что 4 объект не отобразился
id должен быть уникальным (уникальный идентификатор объекта)

Наша разметка зависит от данных которые мы в эту разметку помещаем мы как программисты
думаем как нам правильно составлять данные и как их потом менять а разметка автоматически сама подстроится

Мы добавили 4 элемент а разметка сама не подстроилась
этого не произошло потому что компонент TodoList не правильно структурирован
не правильно построен

Основная ошибка в том что мы явно обращаемся к элементам в массиве по индексу
мы как-будто знаем что у нас должно быть строго 3 таски 
Поэтому 4 таска и не отрисовывается потому что ее просто нет
Поэтому если мы удалим в таскс 2 3 объект приложение будет просто показывать белый экран

Если мы обратимся по индексу массива а в массиве ничего не будет нам вернется undefined

Поэтому код нашей компоненты - не гибкий он не заточен под любое количество тасок
которое может прийти а может и не прийтий

Поэтому мы должны использовать здесь метод массива map
массив это объект
в Todolist в ul Ставим {обозначаем что мы сейчас будем работать с js}
массив находится в props
props.tasks это какой-то массив тасок который приходит в нашу компоненту

Todolist может отрисовываться много раз и tasks могут быть разными и они находятся
в props
props это объект который приходит в нашу компоненту чтобы наша компонента на основе этих данных
могла отрисовать какую-то другую разметку например заголовок props.title 
или например список тасок
поэтому мы должны пробежаться по каждому элементу по каждому объекту в массиве
и делаем это с помощью функции map

{
    props.tasks.map
}

в отличие от forEach map после каждой итерации возвращает на основе старого объекта - новый объект
в новом массиве, нам нужно чтобы он вернул на основе этого объекта - элемент списка - li

1 в map передаю стрелочную функцию

{
    props.tasks.map(  () => {} )
}

Единственным параметром который передается в map является callback функция
с помощью map callback функция вызывается для каждого элемента в tasksData_1_2
этот параметр можно назвать как угодно но лучше чтобы он был в контексте программы

<ul>
    {
        props.tasksData.map((tasksDataItem) => {
            return (
                <li><input type="checkbox" defaultChecked={props.tasksData[0].isDone}/> <span>{props.tasksData[0].title}</span></li>
            )
        })
    }

то есть map возьмет на основе всех объектов tasksData создаст столько же li сколько в tasks находится объектов
но чтобы значения в этой li согласовывались с данными из объектов tasksData мы должны считывать эти значения уже не по индексу
а прямо из параметра callback функции task поэтому в li будут следующие изменения

<ul>
    {
        props.tasksData.map(tasks => {
            <li><input type="checkbox" defaultChecked={task.isDone}/> 
            <span>{task.title}</span></li>
        }
</ul>

И теперь независимо от того сколько объектов мы добавим в массив tasks у нас соответствующее количество
отрисуется и соотв если я укажу в tasksData 2 то у меня 2 объекта и отрисуется.

Рефакторинг так как ничего кроме return функция в map не делает то мы можем сократить запись

map - метод массива который на основе каждого объекта в массиве создает другой элемент
на выходе мы получаем массив с этими новыми элементами

То есть теперь мы просто меняя данные можем автоматически менять разметку

и если мы научимся как-то менять эти данные программным способом, при кликах
по кнопкам и т.д. то у нас будет автоматически происходить перерисовка
и первое что мы научимся делать - удалять таски

Добавляем кнопки справа от span в li

<button>x</button>

Учимся реагировать на события, когда по какому-либо элементу, по кнопке например, 
когда мы кликаем этот элемент генерирует событие клик, 
но так как никто это собтие не слушает, не мониторит,
то ничего и не происходит,
поэтому создаем такого слушателя и добавим тегу button - атрибут onClick
Далее так указываем функцию callback 
Когда произойдет клик функция callback как раз сообщит об этом событии внешнему миру
через функцию которую вызовет кнопка когда с ней произойдет событие клик

И мы отдаем кнопке стрелочную функцию 

<button onClick={() => {}}>x</button>
 
Добавим окошко которое будет вылетать по клику с надписью click

 <ul>
    {
        props.tasksDataApp.map((tasksDataAppItem) =>
            <li>
                <input type="checkbox" defaultChecked={tasksDataAppItem.isDone}/>
                <span>{tasksDataAppItem.title}</span>
                <button className={'deleteButton'} onClick={() => {alert('click')}}>x</button>
            </li>
        )
    }
</ul>

и теперь после нажатия на любую кнопку x будет выводиться окно с надписью click

так как на другие кнопки мы не вешали события onClick то ничего после нажатия по ним не происходит

Функция кнопки x - удалять из отображения браузера конкретную таску, а чтобы реакту было понятно
какую именно таску нужно удалять мы должны каким-то образом идентифицировать конкретный элемент который 
должен быть удален после нажатия на кнопку

Эта идентификация объектов с которыми нужно что-то сделать происходит по id

То есть нам нужно знать id объекта когда мы хотим его например удалить
Вместо click выведем id объекта
мы находимся внутри стрелочной функции которую мы передали в метод map 
map вызывает эту стрелочную функцию для каждой таски в этом массиве поочереди
и при каждом вызове эта таска попадает в параметр task
для которой мы рисуем конкретную li для которой рисуем конкретную кнопку
для которой хотим показать алерт то есть мы к конкретной таске можем достучаться через

task

и я могу к этому task обратиться как к объекту со свойствами каждой таски
например к свойству id

<button onClick={() => { alert(task.id) }}>x</button>

то есть при клике на конкретную кнопку теперь у меня будет отображаться id той таски рядом
с которой я кликнул кнопку то есть мы получили ту самую связь

то есть при клике на кнопку которая лежит в li, которая отрисовалась для конкретной task,
мы повесили конкретную функцию обработчик onClick={() => { alert(task.id) }
на клик конкретной кнопки конкретной li и эта конкретная функция покажет в alert id той таски 
рядом с которой я кликнул кнопку

Для упрощения пока удалим 1 Todolist

Наша задача удалить таску удалить ее мы можем только из данных, в компоненте Todolist мы ее удалить не можем,
массив с тасками находится в App компоненте

То есть данные хранятся в App, а мы эти данные просто как пропсы прокидываем в Todolist и 
Todolist их просто рисует, но мы знаем что мы данные будем менять

то есть мы при нажатии на какие-либо кнопки всегда думаем как нам поменять данные, а уже потом
на основе этих данных произойдет перерисвока

То есть мы должны таким образом писать код для компоненты чтобы потом если вдруг данные меняются
автоматически происходила перерисовка 

Мы подготовили компоненту теперь нужно научиться менять данные

Данные могут менять только функции которые лежат там же где и данные 

Но функцию чтобы она поменяла данные нужно запустить, вызвать, но App сама не может запустить такую функцию
потому что она не знает когда, но Todolist знает, когда нужно запустить эту функцию удаления

Потому что кнопки удаления лежат в Todolist и фактически когда мы кликаем по Tosolist нужно запустить
эту функцию которая лежит в App

Когда у нас данные лежали в App мы передали их в Todolist через props и функция у нас лежит там в App
и мы ее передадим в Todolist так же через props, то есть функция является в js объектом значит ее можно брать
и передавать (передать callback когда сам владелец функции ее не вызывает) App ее не вызывает
а передает куда-то внутрь мы так уже делали с функцией alert('click')

То есть мы ее сами не вызываем мы ее передаем кнопке

<button onClick={() => { alert(task.id) }}>x</button>

И говорим: кнопка, когда по тебе кликнут (onClick) вызови нашу функцию callback

В какой-то степени сама компонента является функцией callback потому что мы ее не вызываем 
мы не видим кода, где у нас конкретно пишется Todolist(); - то есть вызов функции Todolist,
Мы даем инструкцию react в виде jsx разметки и потом эту функцию вызывает React 

Есть еще одна функция callback, это map, мы в map в качестве параметра тоже передаем стрелочную функцию
которая принимает task и возвращает li, мы эту функцию не вызываем, мы ее отдаем map, то есть другой функции
и эта функция map запускает для каждой таски функцию callback

Под задачу удалить таску из массива напишем функцию удаления таски из массива в App

function removeTask() {

}

Но мы не можем удалить task не зная какую именно task удалить
то есть нам как функции удаления нужны входные данные

Функция removeTask лежит там же где и массив с объектами

Удалять объекты из массива будем по id и тут же будет необходимо определить тип под id: number

function removeTask(id: number) {

}

Теперь нам нужно взять этот массив тасок и его изменить, оставив все таски кроме одной
той которую мы удалили для этого используем метод массива filter

map на основе старого массива создает новый массив изменяя каким-либо образом все элементы массива

а filter так же пробегает по всем объектам и пропускает в результирующий массив только те объекты
которые удовлетворяют условию то есть только те таски для которых функция callback переданная в filter
вернёт true 
То есть в новом массиве после filter будут только те таски после прохождения по фильтру которых
filter вернет true

Если написать 

function removeTask(id: number) {
    let filteredTasksData = tasksData.filter(() => {return true})
    console.log(filteredTasksData)
}

то filter вернет те же самые объекты но в новом массиве
Для того чтобы это проверить вызовем эту функцию после клика по кнопке
кнопка находится в Todolist а функция находится в App
значит функцию нужно передать в Todolist через props

<Todolist
    title={'push me'}
    tasksDataApp={tasksData}
    removeTask={removeTask}
/>

в типизации мы укажем 

type TodolistType = {
    title: string
    tasksDataApp: Array<TaskDataType>
    removeTask: Function
}

и теперь мы можем вместо alert вызвать функцию которая у нас находится в props 

То есть мы можем написать вместо alert props.removeTask.id 
таким образом передать в функцию id той кнопки на которую мы нажали для удаления таски

<button onClick={() => { alert(task.id) }}>x</button>            Было
<button onClick={() => { props.removeTask(task.id) }}>x</button> Стало

Итого кнопку нажали в Todolist а функция работает из App компоненты
то есть вызов функции removeTask() произошел в Todolist не смотря на то что сама функция находится в App

Теперь мы должны настроить правильную фильтрацию

То есть мы должны пропустить только те таски у которых id не равна той id которую надо удалить
(на х рядом с которой мы нажали)

как и с map каждая таска приходит с параметром callback функции назовем его 

filteredTask

Далее в filter пишем условие по которому нам фильтр будет фильтровать проходящие через него
объекты массива и после каждого выдавать соотв true либо false

То есть мы говорим если filteredTask.id (таска по которой пробегается фильтр) если ее id не равен
id которая пришла в функцию после клика по кнопке в Todolist то мы тогда возвращаем true
и таску отображаем
а если id таски фильтра равна id таски с кнопки х todolista то возвращаем false и таску не отображаем

function removeTask(id: number) {
    let filteredTasksData = tasksData.filter((filteredTask) => {
        if (filteredTask.id !== id) return true
        else return false
        })
}

То есть мы выше сравниваем id кнопки по которой мы нажали с id таски из данных, и если они совпадают
не показываем эту таску с помощью того что фильтр возращает новый массив уже без нее
т.о. мы меняем данные

Если мы нажмем на x с id 3 то для таски с id 3 filter вернет false значит эта таска не попадет в 
результирующий массив 

if (1 !== 3) true - отобрази
if (2 !== 3) true - отобрази
if (3 !== 3) false - не отображай
if (4 !== 3) true - отобрази

Соответственно в результирующем массиве у нас будут таски с id 1 2 4 а 3 - нет

_________________________Рефакторим filter 

так как булевое выражение итак нам возращает true либо false
то
мы можем упростить наш код

function removeTask(id: number) {
    let filteredTasksData = tasksData.filter((filteredTask) => {
    return filteredTask.id !== id
}
filteredTask.id !== id превращается либо в true либо в false
а filter добавит в новый массив только там где true
поэтому id присовпадении не попадут в результирующий массив

Если наша стрелочная функция не делает ничего кроме return то мы можем удалить {} и return

итого

function removeTask(id: number) {
    let filteredTasksData = tasksData.filter(filteredTask => filteredTask.id !== id)
}

Фильтр пропусти те таски id которых не равна id которую надо удалить

Но это все будет отображать уже в другом массиве, старый массив мы не меняли
фильтрация не меняет старый массив она пробегается по старому массиву и создает новый массив
с отфильтрованными тасками поэтому этот массив не изменился поэтому на данном этапе перерисовки 
после нажатия на х - нет

Но мы можем не создавать новую переменную filteredTasksData а так как у нас массив данных объявлен с помощью
let то мы можем просто переприсвоить тому же самому массиву данных tasksData новое значение
поэтому

из 

function removeTask(id: number) {
    let filteredTasksData = tasksData.filter(filteredTask => filteredTask.id !== id)
}

мы делаем 

function removeTask(id: number) {
    let tasksData = tasksData.filter(filteredTask => filteredTask.id !== id)
}

Если функция видит внутри себя наименование переменной которой нет внутри этой функции
то она ее берет из замыкания снаружи, за пределами литерала {} функции 
Это называется замыкание

Итак на данный момент после нажатия x через debugger видим как такси удаляются 
а в браузере перерисовка не происходит

Потому что реакт отрисовывает App, Todolist и так далее по цепочке, останавливается, и только потом
мы нажимаем кнопку, данные изменяются, но React заново не отрисовывает страницу 
поэтому на странице ничего не меняется

Потому что данные нам нужно хранить определенным, специальным образом 
чтобы эта перерисовка происходила автоматически

в пути самурая rerenderentiretree мы насильно извне перерисовываем компоненту 

Здесь мы будем использовать локальный стейт компонента

Раньше существовало два типа компонент функциональные и классовые

классовый компонент - то что уходит в прошлое, но раньше они широко использовались
потому что классовые компоненты имеют локальный стейт
Локальный стейт, это такой стейт, который если меняется - перерисовывает реакт компоненту

в функциональных компонентах такого не было, но в функциональных компонентах
научились использовать локальный стейт с помощью хука useState

useState

Скажем что мы будем хранить таски по другому не в переменной tasksData а в useState

useState() это специальная функция-хук которая находится в реакте 
при использовании она импортируется из реакт

мы говорим useState - сохрани данные в стейт, который будет отслеживаться реактом и если данные изменятся
то реакт автоматически перерисует компоненту в который мы написали useState

useState - хранилище, он конкретно прописан в App, значит у App - появляется свое хранилище
за которым React наблюдает и мы в этот useState помещаем нам массив tasksData

useState(tasksData)

Нам этим массивом нужно как-то пользоваться
То что мы помещаем tasksData в useState это первоначальное состояние, initial state - которому со старта будет 
равняться наш стейт при первом его написании.

Но он со временем может поменяться, и нам нужно к измененному tasksData обращаться 

Поэтому useState returnит массив в котором находится два элемента

[data, () => {}] 1 элемент это данные, а второй - функция которая эти данные меняет

в нашем случае вместо data данных выступает массив объектов [{},{},{}] и функция которая может этот массив поменять
() => {}

и вот useHook нам возвращает такой массив let array = [ [{},{},{}], () => {}] 

то есть мы вызываем функцию

useState()

которая принимает данные

useState(data) 

и которая возвращает массив

useState(data) {
    return [ [{},{},{}], () => {}];
}

то есть мы вызываем useState() и говорим вот тебе массив tasks

useState([{},{},{}])

useState берет массив тасок и возвращает обратно

function useState(data: any) {
    return [ data, () => {}];
}

то есть в useState(data: any) упаковывает data в массив тасок, а вторым парамтером функцию 
которая этот массив тасок умеет менять

и нам этот массив возвращается обратно

let array = useState({},{},{})

и мы можем обратиться к array[0] и это будет массив тасок который мы и передали
и можем обратиться к array[1] чтобы получить функцию которая меняет данные
и обычно эти два значения присваются и говорят 

let useStateTasksData = array[0]

а функция которая сидит вторым элементом в этом массиве называется 

setTasks = array[1] установить таски

То есть useState нам возвращает массив

let array = useState(tasksData)

и в этом array сидит 2 элемента

под первым элементом сидят таски
под вторым элементом сидит функция которую мы можем вызвать чтобы установить новые таски

let tasksDataUseState = array[0]
let setTasks = array[1]

то есть когда мы изменим массив tasksData мы можем этот массив отправить в 
функцию setTasks и таски изменятся там в стейте который контролируется реактом
и реакт автоматически запустит перерисовку

фильтр фильтрует по тасксдата мы получили фильтрованные таски
и теперь если мы эти отфильтрованные таски отправим в функцию setTasks
тем самым мы скажем что измени в стейте таски которые там были 
setTasks(filteredTasks)

function removeTask(id: number) {
    let filteredTasks = useStateTasksData.filter(filteredTask => filteredTask.id !== id)
    setTasks(filteredTasks)
}

А раз таски изменились с помощью setTasks реакт запустит перерисовку
точнее чтобы перерисовку вообще получить реакту нужно запустить заново функцию в которой 
этот стейт изменился

Реакт заново перезапускает функцию App он видит что мы используем функцию 

let arrayUseState = useState(tasksData)

и в этот useState засовываем опять 4 таски из tasksData

То есть у нас 4 таски из tasksData поместились в стейт

let arrayUseState = useState(tasksData)

таска потом удаляется и мы в стейте оставляем только три таски

setTasks(filteredTasks)

И реакт зная что стейт изменился перезапускает функцию App
и он видит опять что мы помещаем 4 таски в useState но useState больше их в себя не помещает
потому что это уже было то есть инициализационного начального значения массива tasksData 
как-будто уже и не происходит

let tasksData = ;

let arrayUseState = useState()

эта часть кода пропускается далее видит useState из useState достаю массив

let arrayUseState = useState()

let useStateTasksData = arrayUseState[0] в этом массиве беру первый элемент
там уже после удаления осталось три таски 

по прежнему получаю функцию которую опять можно вызывать чтобы опять изменять таски

let setTasks = arrayUseState[1]

и иду вниз и отрисовываю опять Todolist и передаю уже три таски туда внутрь

tasksDataApp={useStateTasksData}

<Todolist
    title={'push me'}
    useStateTasksData={useStateTasksData}
    removeTask={removeTask}
/>


_________________________________ Упрощенный пример useState

Создаем функцию Counter (компонент)
который возвращает div в которой находится какое-то значение

function Counter {
    return (
        <div>
        
        </div>
    )
}

это значение мы будем хранить в useState

мы скажем useState изначально ты будешь равен 5

function Counter {
    useState(5) 
    return (
        <div>

        </div>
    )
}

Нам useState возвращает массив 

function Counter {
    let array = useState(5) 
    return (
    <div>
    
    </div>
        )
}

И мы к этой пятерке можем обратиться как к array[0]
array[0] === 5

let data = array[0]

и мы можем эти данные отобразить в div

function Counter {
let array = useState(5)
    return (
        <div>
            {data}
        </div>
        )
}

в index.tsx изменим App на Counter и на странице увидим 5 потому что data = array[0] = 5

Ставим console.log('Counter rendered') чтобы посмотреть сколько раз компонента вызвалась

а значение с которым отрендерилось мы будем видеть в разметке

в логе видим Counter rendered

Реакт вызывает функциональную компоненту Counter 

function Counter {
    let array = useState(5)
    let data = array[0]
    
    return (
        <div>
            {data}
        </div>
    )
}

Реакт вызывает функцию Counter и рисует её, в логе появляется Counter rendered
здесь он внутри видит что мы используем useState - let array = useState(5)

Поэтому он именно для этой отрисовки 5 которую он уже сделал
Он запомнил что конкретно для этого Counter уже есть стартовое значение в дивке и оно равно 5
и его возвращаю назад в массив array чтобы ее можно было отрисовать - data
и отрисовывает

А дальше если вдруг эта 5 будет меняться именно с помощью 
сет функции которая тоже сидит в этом массиве вторым элементом

назовем ее setData (этой переменной можем дать любое имя)

function Counter {
    let array = useState(5)
    let data = array[0]
    let setData = array[1]

    return (
        <div>
            {data}
        </div>
    )
}

Если мы эту функцию вызовем например при клике на саму дивку <div onClick={() => {setData}}>
< onClick={() => {}}> - обработчик события

function Counter {
    let array = useState(5)
    let data = array[0]
    let setData = array[1]

    return (
        <div onClick={() => {setData}}>
            {data}
        </div>
    )
}

и укажем в качестве параметра функции setData() наш первый элемент массива + 1

function Counter {
    let array = useState(5)
    let data = array[0]
    let setData = array[1]

    return (
        <div onClick={() => {setData(data+1)}}>
            {data}
        </div>
    )
}

то у нас при нажатии цифра на странице будет увеличиваться на 1

it works!

_________________________________________________________Explaining

Counter - вызвалась. здесь 5 ->  let data = array[0] === 5
и мы эту пятерку отрисовали 
 <div>{data}</div>

далее мы кликаем <div onClick={() => {setData(data+1)}}></div>

у нас вызывается функция setData
Так как эта setData у нас из массива который из useState -> let setData = array[1] -> let array = useState(5)
То вызов этой {setData(data+1)}} - заставляет изменить данные -> data которые локально относятся к Counter

Соответственно в data для этого Counter в локальном стейте после 1 клика будет - 6
то есть 6 будет в данных

Раз стейт поменялся реакт вызывает функцию опять потому что реакт понимает что от этих данных зависит отрисовка 
то есть эти данные data используются в отрисовке и так как данные используются в отрисовке 
нужно отрисовку получить новую, а чтобы получить новую нужно вызвать функцию Counter

Нужно вызвать эту же функцию Counter для отрисовки Counter реакт ее вызывает и уже хоть в useState
при втором прочтении кода опять передает в параметре 5, 

но теперь когда отрисовка идет второй раз, реакт игнорирует эту 5 
потому что 5 - это было стартовое значение initialState которое реакт уже увеличил до 6 
и он возвращает нам массив в котором сидит 6 -> let data = array[0] -> 6


let array = useState(5)
let data = array[0]      --- второй раз здесь уже 6
let setData = array[1]

и поэтому 6 попадает в <div>{data}</div> и перерисовывается

______________________________________________________________________________________________________________________


То есть jsx зависит теперь от данных которые находятся внутри компоненты useState и от тех которые приходят
в props

В случае с Counter данные в props не приходят и то что мы видим на странице зависит только от данных в локальном стейте

Аналогичная ситуация с App

App не принимает props, поэтому его отрисовка зависит от данных которые находятся в нем в качестве useState
и изменяются в нем же

Но если App вдруг перерисовывается то
перерисовка App заставляет перерисоваться Todolist 

а в Todolist уже попадают данные useStateTasksData={useStateTasksData}

<Todolist
    title={'Benny Benassi'}
    useStateTasksData={useStateTasksData}
    removeTask={removeTask}
/>

Данные которые достаются из массива который возвращает useState

let arrayUseState = useState(tasksData)
let useStateTasksData = arrayUseState[0]
let setTasks = arrayUseState[1]

Но уже эти данные будут изменены относительно initial state
Соответственно эти данные заставляют перерисоваться наш Todolist
____________________________________________________________________________________________________________________

Есть данные из props а есть данные самой компоненты то есть ее локальный стейт и то и то используется для 
отображения jsx разметки

Если есть локальные данные (стейт) то есть и функции которые эти данные может менять в нашем случае useState

Если эта функция вызовется при клике на элемент из jsx разметки то локальные стейт (данные) изменятся
и реакт заново перерисует эту компоненту то есть сама функция-компонента - перезапустится 
и у нас вернется новая jsx разметка

Обычно jsx рисует подкомпоненты относительно компоненты родителя
там находится кнопка которую можно нажать
соответственно сетфункция которая изменяет данные в локальном стейте компоненты родителя
функция которая меняет этот локальный стейт - это первая функция.
вторая функция это которая вызывает первую функцию 

в нашем случае removeTask после filter вызывает функцию setTasks
который меняет непосредственно стейт который был возвращен из useState

То есть мы делаем эту логическую функцию Flogic которая делает какую-то логику
потом получает новые данные и вызывает сетфункцию чтобы эти данные обновили стейт
стейт обновляется компонента перерисовывается

эта функция removeTask обычно вызывается перекидывается в jsx как callback другой компоненте
в нашем случае мы отдале ее Todolist

__________________________________________________________________________________ Ещё раз 

Есть сетфункция setTasks которая меняет данные 
Эта сетфункция вызывается после какой-то логической обработки в нашем случае filter
внутри другой функции в нашем случае removeTask выглядит так:

function removeTask(id: number) {
    let filteredTasksData = useStateTasksData.filter(filteredTask => filteredTask.id !== id)
    setTasks(filteredTasksData)
}

а эта другая функция removeTask отдается как callback другой подкомпоненте

<Todolist
    title={'Benny Benassi'}
    useStateTasksData={useStateTasksData}
    removeTask={removeTask}
/>

и этот callback вызывается в подкомпоненте при клике например на кнопку

<button onClick={() => {props.removeTask(task.id)}}>x</button>

___________________________________________________________________________________

                                                    Рефакторинг
let arrayUseState = useState(tasksData)
let useStateTasksData = arrayUseState[0]
let setTasks = arrayUseState[1]

Доставание элементов из массива и присваивание переменным не очень удобное 

Тоже самое можно сделать короче

Нужно сказать что мы объявляем 2 переменные которые мы хотим получить извлечением элементов из массива, выглядит так:

Было

let arrayUS = useState(tasksData)

let tasksDataUS = arrayUS[0]     --->           let [tasksDataUS, setTasksUS] = arrayUS
let setTasks = arrayUS[1]        --->

Стало

let arrayUS = useState(tasksData)

let [tasksDataUS, setTasksUS] = arrayUS

в массиве arrayUS -> 2 элемента поэтому 1 элемент с данными присвоится tasksDataUS
второй элемент с сетфункцией изменяющей данные из 1-го элемента присвоится setTasksUS

Ещё нам не нужна переменная arrayUS вместо - let arrayUS = useState(tasksData) мы можем написать

let [tasksDataUS, setTasksUS] = useState(tasksData)

Было 

let arrayUS = useState(tasksData)
let [tasksDataUS, setTasksUS] = arrayUS

Стало

let [tasksDataUS, setTasksUS] = useState(tasksData)

Далее избавляемся от переменной tasksData, помещаем все данные сразу в useState

let [tasksDataUS, setTasksUS] = useState([
    {id: 1, title: 'push me', isDone: true },
    {id: 2, title: 'and then just touch me', isDone: true },
    {id: 3, title: 'till i can get my', isDone: true },
    {id: 4, title: 'satisfaction', isDone: true },
])

Учимся фильтровать данные из tasksDataUS через добавление функционала к кнопкам 
All - все 
Active - без галочки не выполненные 
Completed - только те которые с галочками 
находящихся в Todolist

Первым делом учимся делать зависимость разметки от данных 
Чтобы после удаления объекта в массиве объектов вручную на странице это отображалось
Первым делом нужно подумать о том что я при клике на кнопки меняю что-то что влияет на то какие таски передаются

Нам нужно будет хранить какие-то данные
При нажатии на кнопки нам нужно будет менять не массив удаляя и добавляя в него элементы
а менять значение в фильтре 
То есть какой у нас сейчас фильтр All Active либо Completed 
А раз значение меняется и мы хотим чтобы после изменения проиходила отрисовка 
То тогда мы должны использовать useState
И мы useState можем вызывать внутри компоненты многократно
поэтому под 

    let [tasksDataUS, setTasksUS] = useState([
        {id: 1, title: 'push me', isDone: true },
        {id: 2, title: 'and then just touch me', isDone: true },
        {id: 3, title: 'till i can get my', isDone: true },
        {id: 4, title: 'satisfaction', isDone: true },
    ])

пишем 

    let [filter, setFilter]

filter - название переменной которая означает какие данные мы в ней храним  
setFilter - функция с помощью которой мы будем эти сохраненные данные изменять
и которая позволит реакту перерисовать компоненту 

дописываем 

let [filter, setFilter] = useState('all')  -> all значит что после загрузки страницы будут отрисовываться все сразу

И дальше мы можем пустить в Todolist не все таски tasksDataUS

<Todolist title={'Benny Benassi'} tasksDataUS={tasksDataUS} removeTask={removeTask} />

а отфильтрованные таски, выше return в App создадим переменную tasksForTodolist
изначально присвоим сами данные tasksDataUS целиком 

let tasksForTodolist = tasksDataUS

но потом поставим условие, если значение filter = completed то мы в переменную 

tasksForTodolist запишем таски которые отфильтрованы 

if (filter === 'completed') {
    tasksForTodolist = tasksDataUS.filter - помним что фильтр не меняет сам объект tasksData
} фильтр создает новый массив который запишется в tasksForTodolist в который пропускает элементы
которые возвращают true 
И если у одной таски isDone === true то тогда таска попадет в результирующий массив tasksForTodolist
а если у таски - false то есть она не выполненая, значит isDone - false и значит она не попадет в tasksForTodolist

if (filter === 'completed') {
tasksForTodolist = tasksDataUS.filter(task => task.isDone === true) 
}

и далее мы tasksForTodolist прокидываем в атрибут подкомпоненты App - Todolist
Чтобы Todolist получил не все таски а только те таски которые прошли фильтрацию

<Todolist title={'Benny Benassi'} tasksDataUS={tasksForTodolist} removeTask={removeTask} />

И второе условие пропускаем в переменную tasksForTodolist те таски у которых isDone = false
то есть которые не выполнены еще 
и их пропускаем записываем в этот новый массив tasksForTodolist

if (filter === 'active') {
tasksForTodolist = tasksDataUS.filter(task => task.isDone === false)
}

Изначально у нас в стейте all поэтому мы видим все таски
теперь если мы вручную поменяем в useState('all') на completed то увидим только те таски у которых галочка стоит
а если на active то все не выполненые

То есть наша разметка начала подстраиваться под данные 

То есть мы сделали ту самую зависимость в jsx разметке от данных

Осталось сделать так чтобы замена происходила при нажатии на кнопки

1 Делаем разметку
2 Делаем данные 
3 Делаем разметку зависимой от этих данных чтобы меняя данные разметка тоже менялась

Когда мы выстроили такую зависимость потом уже можем делать обработчики события нажатия на кнопки
чтобы при нажатии на что-либо происходило какое-либо действие
Прежде чем мы это будем делать

Мы должны сказать что у нас набор этих фиксированных слов active completed all он ограничен
чтобы не ошибиться
Либо это active либо completed либо all
и для этого мы создадим отдельный тип 
Выйдем за пределы функции и экспортируем типизацию FilterValuesType

и говорим что это либо all либо active либо completed 

type FilterValuesType = 'all' | 'completed' | 'active'

то есть в качестве типа мы берем фиксированные строки 
Далее мы говорим что мы в useState сохраняем наш новый тип FilterValuesType

let [filter, setFilter] = useState<FilterValuesType>('all')

и теперь я не могу ошибиться при задании типа для данного useState а так же в условии if 

if (filter === 'active') 

потому что filter который был возвращен useState

он может быть либо all либо active либо completed 

и мы здесь тоже ошибиться не можем 

Соответственно TypeScript начинает контролировать то чтобы мы не ошиблись

Так же для дополнительного контроля TypeScript мы можем задать дополнительную типизацию
для первого useState

let [tasksDataUS, setTasksUS] = useState<Array<tasksDataUSType>>([

Таким образом мы говорим что у нас массив тасок который мы передаем в useState

Array<tasksDataUSType> - здесь мы уточнили массив
<Array<tasksDataUSType>> - здесь мы уточняем useState

Теперь нам надо менять второй стейт через сетфункцию setFilter
но над этим setFilter у нас есть другая логическая функция которая устанавливает фильтр в зависимости от чего либо

Поэтому мы для этого setFilter создадим функцию которая называется changeFilter

Ту самую логическую функцию 

function changeFilter() {

}

Она будет принимать значение value для нового фильтра это value должно быть обязательно FilterValuesType
то есть или all или complete или active 
function changeFilter(value: FilterValuesType) {

}

и дальше внутри этой функции нужно вызвать setFilter которой передадим value 

function changeFilter(value: FilterValuesType) {
    setFilter(value)
}

Теперь эту функцию changeFilter которая вызываться здесь не будет потому что в App нет кнопок
которые ее будут вызывать
мы эту функцию changeFilter передадим callback в Todolist 
А эти кнопки, они уже сидят в Todolist, они уже вызовут эту функцию когда по кнопкам будет произведен клик

Делаем 

<Todolist
title={'Benny Benassi'}
tasksDataUS={tasksForTodolist}
removeTask={removeTask}
changeFilter={changeFilter}
/>

Вносим её в типизацию 

type TodolistType = {
    title: string
    tasksDataUS: Array<tasksDataUSType>
    removeTask: Function
    changeFiler: Function
}

И дальше мы можем этот changeFilter вызывать например при кликах на кнопки в Todolist

присваиваем onClick кнопке тем самым говорим
кнопка когда по тебе кликнут, ты вызовешь callback функцию а я вызову функцию changeFilter
которая сидит в props и передам ей all в соответствии с названием кнопки

<button onClick={() => {props.changeFilter('all')}}>All</button>
<button onClick={() => {props.changeFilter('active')}}>Active</button>
<button onClick={() => {props.changeFilter('completed')}}>Completed</button>

И теперь будет автоматически вызываться changeFilter который к нам пришел из App в props к Todolist из App
через атрибут Todolist 
changeFilter в свою очередь получает значение value и передает его в setFilter
setFilter приходит из useState из хука поэтому стейт меняется и компонента заново вызывается чтобы 
перерисоваться с новыми данными 
срабатывает новая фильтрация и только те таски что нужно попадают в todolist

Но мы не протипизировали значение которые мы указали в 

<button onClick={() => {props.changeFilter('all')}}>All</button>
<button onClick={() => {props.changeFilter('active')}}>Active</button>
<button onClick={() => {props.changeFilter('completed')}}>Completed</button>

all active completed

мы указали что функция просто Function в типизации выше 

type TodolistType = {
    title: string
    tasksDataUS: Array<tasksDataUSType>
    removeTask: Function
    changeFilter: Function
}

это неверно, это значит какая угодно функция, то есть мы могли вообще ничего не передавать и TS не ругается

<button onClick={() => {props.changeFilter('')}}>All</button>
<button onClick={() => {props.changeFilter('')}}>Active</button>
<button onClick={() => {props.changeFilter('')}}>Completed</button>

Для этого мы пишем в типизации 

changeFilter: (value: FilterValuesType) => void

что функция принимает value которое затипизировано FilterValuesType и возвращает void то есть ничего
после => указываем что эта функция возвращает void - ничего не возвращает

(value: FilterValuesType) - а здесь пишем что функция принимает

аналогично для removeTask

removeTask: (id: number) => void

всё 

it works!

Итоги

У нас есть компонента App которая передает внутри себя отрисовывает компоненту Todolist 
В Todolist App передает какие-то данные 
так происходит потому что Todolistов затем мы можем отрисовать много
Каждый Todolist должен быть уникальным поэтому каждый Todolist получает на входе данные 
в виде атрибутов они оже объект props которые надо типизировать чтобы все не пошло крахом 
Мы не можем передавать какие хочешь props для этого нам нужна типизация
Чтобы мы четко пользовались и передавали в Todolist четко именно то что он ждет 

Компонента принимает props для того чтобы 
1 среди этих props есть данные, а есть callback, благодаря тому что мы в компоненту можем засунуть и данные и callback
эта компонента может реагировать и вести себя по разному 
получая разные данные в виде атрибутов компонента может их по разному отрисовывать
один и тот же Todolist нарисовала разные title и разные данные а во вторых получая callback 
компонента может вести себя по другому 
запуская наши callback removeTask changeFilter
и мы их передаем в качестве аргументов 

Если Todolist было бы два, функции changeFilter и removeTask тоже было бы по две

То есть мы извне задаем как себя вести компоненте Todolist
говорим что она должна отрисовать какие данные и что ты должен вызвать когда у тебя там 
что-то внутри произойдет 
потому что мы тут снаружи можем управлять тем что ты нам передашь
потому что данные хранятся в App а там где хранятся данные должны храниться и функции которые эти данные меняют

Задача Todolist отрисовать что ему дали и его задача сообщить наверх вызвав callback которые мы передали 
в качестве функций changeFilter и removeTask в качестве аргументов - сообщить наверх о том
что какое-то действие хочет совершиться с той частью jsx разметки которую мы передали в Todolist

Соотв мы передаем эти callback в виде функций changeFilter и removeTask а дальше 
есть только Todolist который просто принимает props 

непереводимый итальянский фольклёр

Если мы удалим содержимое функции removetask то Todolist как отрисовывал все что ему приходило
так и будет это делать 

Все решают данные либо компонента в которой они хранятся

Аналогично с фильтрацией


















